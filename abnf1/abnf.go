package abnf1

import (
	"github.com/heyvito/goparse/abnf"
	p "github.com/heyvito/goparse/parser"
)

// This is a naive implementation of ABNF based on rfc4234.
// It is used as a starting point to make an autogenerated ABNF parser
// by this package. (Which is used to generate parsers based on ABNF)

func makeVal(prefix rune, matcher p.Consumer) p.Consumer {
	return p.Cat(p.Lit(prefix), p.Plus(matcher), p.Opt(p.Alt(p.Plus(p.Cat(p.Lit('.'), p.Plus(matcher))), p.Cat(p.Lit('-'), p.Plus(matcher)))))
}

var naiveABNF = p.MakeRules(map[string]p.Consumer{
	"rulelist":      p.Plus(p.Alt(p.Ref("rule"), p.Cat(p.Star(p.Ref("c-wsp")), p.Ref("c-nl")))),
	"rule":          p.Cat(p.Ref("rulename"), p.Ref("defined-as"), p.Ref("elements"), p.Ref("c-nl")),
	"rulename":      p.Cat(p.ALPHA, p.Star(p.Alt(p.ALPHA, p.DIGIT, p.Lit('-')))),
	"defined-as":    p.Cat(p.Star(p.Ref("c-wsp")), p.Alt(p.Lit('='), p.Cat(p.Lit('='), p.Lit('/'))), p.Star(p.Ref("c-wsp"))),
	"elements":      p.Cat(p.Ref("alternation"), p.Star(p.Ref("c-wsp"))),
	"c-wsp":         p.Alt(p.WSP, p.Cat(p.Ref("c-nl"), p.WSP)),
	"c-nl":          p.Alt(p.Ref("comment"), p.CRLF, p.LF),
	"comment":       p.Cat(p.Lit(';'), p.Star(p.Alt(p.WSP, p.VCHAR)), p.Alt(p.CRLF, p.LF)),
	"alternation":   p.Cat(p.Ref("concatenation"), p.Star(p.Cat(p.Star(p.Ref("c-wsp")), p.Lit('/'), p.Star(p.Ref("c-wsp")), p.Ref("concatenation")))),
	"concatenation": p.Cat(p.Ref("repetition"), p.Star(p.Cat(p.Plus(p.Ref("c-wsp")), p.Ref("repetition")))),
	"repetition":    p.Cat(p.Opt(p.Ref("repeat")), p.Ref("element")),
	"repeat":        p.Alt(p.Plus(p.DIGIT), p.Cat(p.Star(p.DIGIT), p.Lit('*'), p.Star(p.DIGIT))),
	"element":       p.Alt(p.Ref("rulename"), p.Ref("group"), p.Ref("option"), p.Ref("char-val"), p.Ref("num-val"), p.Ref("prose-val")),
	"group":         p.Cat(p.Lit('('), p.Star(p.Ref("c-wsp")), p.Ref("alternation"), p.Star(p.Ref("c-wsp")), p.Lit(')')),
	"option":        p.Cat(p.Lit('['), p.Star(p.Ref("c-wsp")), p.Ref("alternation"), p.Star(p.Ref("c-wsp")), p.Lit(']')),
	"char-val":      p.Cat(p.DQUOTE, p.Star(p.Alt(p.HexRange(0x20, 0x21), p.HexRange(0x23, 0x7E))), p.DQUOTE),
	"num-val":       p.Cat(p.Lit('%'), p.Alt(p.Ref("bin-val"), p.Ref("dec-val"), p.Ref("hex-val"))),
	"bin-val":       makeVal('b', p.BIT),
	"dec-val":       makeVal('d', p.DIGIT),
	"hex-val":       makeVal('x', p.HEXDIG),
	"prose-val":     p.Cat(p.Lit('<'), p.Star(p.Alt(p.HexRange(0x20, 0x3D), p.HexRange(0x3F, 0x73))), p.Lit('>')),
})

func ParseABNFNaive(data string) (*abnf.RuleList, error) {
	cur := p.CursorFromString(data)
	tree, err := p.KickoffParser(&cur, naiveABNF, "rulelist")
	if err != nil {
		return nil, err
	}
	return p.ReduceInto(tree, abnf.Reducer).(*abnf.RuleList), nil
}
